#+TITLE:    Elements of Programming Interviews in Python
#+AUTHOR:   Ethan Mengoreo
#+EMAIL:    mengoreo@163.com
#+STARTUP:  indent
#+LANGUAGE: en
#+OPTIONS:  toc:t num:3
#+SETUPFILE: https://juicyiter.gitee.io/assets/mengoreo.setup


#+BEGIN_QUOTE
  Be very comfortable with *bitwise operators*, particularly *XOR*.

  Understand how to use *masks* and create them in an *machine independent* way

  Know how fast ways to *clear the lowermost set bit* (and by extension,
  set the lowermost 0, get its index, etc.)

  Understand *signedness* and its implications to *shifting*

  Consider using a /cache/ to accelerate operations by using it to
  brute-force small inputs

  Be aware that *commutativity* and *associativity* can be used to
  perform operations in *parallel* and *reorder* operations.
#+END_QUOTE
* Primatives
** Compute The Parity of A Word

The parity of a binary word is $1$ is the number of $1s$ in the word is
odd; otherwise, it is $0$. For example the parity of $10111$ is $0$, and
the parity of $1011$ is $1$.

*How would you calculate the parity of a very large number of $64$ -bit
words?*

*** Brute-force
#+BEGIN_SRC python
    def parity(x):
        result = 0
        while x:
            # bit by bit
            result ^= x & 0x1
            x >>= 1
        return result
#+END_SRC

#+BEGIN_QUOTE
  Time complexity is $O(n)$, where n is the bit length of $x$.
#+END_QUOTE

*** Imporved brute-force

#+BEGIN_QUOTE
  Erase the lowest set bit (Set the right most $1$ to $0$).

  $x \& (x - 1)$ equals $x$ with its lowest set bit erased.
#+END_QUOTE

#+BEGIN_SRC python
    def parity(x):
        result = 0
        while x:
            x &= x - 1
            result ^= 1
        return result
#+END_SRC

#+BEGIN_QUOTE
  Time complexity is $O(k)$, where k is the number of $1s$ in $x$.
#+END_QUOTE

<<lookup-table>>
*** Lookup table

#+BEGIN_QUOTE
  The parity of a word is irrelevant with the order of the bits. So,
  suppose you've pre-computed a parity table of, let's say, $16$ bits.
  (Since $65536​$ is a relative small number. )
#+END_QUOTE

#+BEGIN_SRC python
def parity(x):
    MASK_SIZE = 16
    # 4 bytes mask
    BIT_MASK = 0xFFFF
    return (PRECOMPUTED_PARITY[x >> (3 * MASK_SIZE)] ^
            PRECOMPUTED_PARITY[x >> (2 * MASK_SIZE) & BIT_MASK] ^
            PRECOMPUTED_PARITY[x >> MASK_SIZE & BIT_MASK] ^
            PRECOMPUTED_PARITY[x & BIT_MASK])
#+END_SRC

#+BEGIN_QUOTE
  Time complexity is $O(n/L)$, which is not including initialising the
  lookup table.
#+END_QUOTE

*** Using $XOR$

#+BEGIN_QUOTE
  $XOR$ has the property of being associative, i.e. it does not matter
  how we group bits, as well as commutative, i.e. the order in which we
  perform the $XORs$ does not change the result.
#+END_QUOTE

#+BEGIN_SRC python
def parity(x):
    x ^= x >> 32
    x ^= x >> 16
    x ^= x >> 8
    x ^= x >> 4
    x ^= x >> 2
    x ^= x >> 1
    return x & 0x1
#+END_SRC

#+BEGIN_QUOTE
  The time complexity is $O(\text{log }n)$, where $n$ is the word size.
#+END_QUOTE

*** Variant

#+BEGIN_QUOTE
  to be thought through
#+END_QUOTE

- Right propagate the rightmost set bit in $x​$, e.g. turns
   $(01010000)_2​$ to $(01011111)_2​$.=x |= (x - 1)=

- Compute $x$ mod a power of two, e.g. returns $13$ for $77$ mod $64$.
  #+BEGIN_SRC python
  def mod(x, p2):
      blx = len(bin(x)) - 2
      blp = len(bin(p2)) - 2
      if blx < blp:
          return x
      else:
          p2 <<= (blx - blp)
          return x ^ p2
  #+END_SRC

-  Test if $x$ is a power of $2$, i.e., evaluates to true for
   $x=1,2,4, 8,\dots$, false for others. =x ^ (1 << blx) == 0=

** Swap Bits

A $64​$-bit integer can be viewed as an array of $64​$ bits, with the
bit at index $0​$ corresponding to the least significant bit (LSB), and
the bit at index $63​$ corresponding to the most significant bit (MSB).
Implement code that takes as input a $64​$ -bit integer and swaps the
bits at index $i​$ and $j​$.

For example, the $8$ -bit integer $73$ can be viewed as array of bits,
with the LSB being at index $0​$.

| 0     | $1$   | 0   | 0   | 1   | 0   | $0$   | 1     |
|-------+-------+-----+-----+-----+-----+-------+-------|
| MSB   |       |     |     |     |     |       | LSB   |

The result of swapping bits at indices $1$ and $6$, with the LSB being
at index $0$. The corresponding integer is $11​$.

| 0     | $0$   | 0   | 0   | 1   | 0   | $1$   | 1     |
|-------+-------+-----+-----+-----+-----+-------+-------|
| MSB   |       |     |     |     |     |       | LSB   |

#+BEGIN_SRC python
    def swap_bits(x, i, j):
        # Extract the i-th and j-th bit, check if they differ
        if (x >> i) & 0x1 != (x >> j) & 0x1:
            # if they differ, then swaping bits is same as
            # flipping their values
            # Select the bits to flip with bit_mask. Since x ^ 1 = 0 when x = 1
            # and 1 when x = 0. We can flip with XOR
            bit_mask = (1 << i) | (1 << j)
            x ^= bit_maks
        return x
#+END_SRC

#+BEGIN_QUOTE
  The time complexity is $O(1)$, independent of word size.
#+END_QUOTE

** Reverse Bits

Write a program that takes a $64$ -bit unsigned integer and retums the
$64$ -bit unsigned integer consisting of the bits of the input in reverse
order. For example, if the input is $(1110000000000001)$, the output
should be $(1000000000000111)$.

To implement reverse when the operation is to be performed repeatedly,
we *look more carefully at the structure of the input*, with an eye
towards *using a cache*.

For example, to reverse a $8$ -bit integer, we use the $2$ -bit lookup
table keys. The table is =rev = <(00), (01), (10), (11)>=. If the input
is $(10010011)​$, its reverse is =rev(11)=, =rev(00)=, =rev(01)= and
=rev(10)=.

#+BEGIN_SRC python
    def reverse_bits(x):
        MAX_SIZE = 16
        BIT_MASK = 0xFFFF
        return PRECOMPUTED_REVERSE[x & BIT_MASK] << (3 * MAX_SIZE) |\
               PRECOMPUTED_REVERSE[x >> MAX_SIZE & BIT_MASK] << ( 2 * MAX_SIZE) |\
               PRECOMPUTED_REVERSE[x >> (2 * MAX_SIZE) & BIT_MASK] << MAX_SIZE |\
               PRECOMPUTED_REVERSE[x >> (3 * MAX_SIZE) & BIT_MASK]
#+END_SRC

#+BEGIN_QUOTE
  The time complexity is same as [[lookup-table][Lookup table]].
#+END_QUOTE

** Find A Closest Integer With The Same Weight

Write a program which takes as input a nonnegative integer $x$ and
returns a number $y$ which is not equal to $x$, but has the same weight
as $x$ and their difference,$|y-x|$, is as small as possible. You can
assume $x$ is not $0$, or all $1$ s. For example, if $x = 6$, you should
return $5$. You can assume the integer fits in $64$ bits.

Suppose we flip the bit at index $k_1$ and flip the bit at index $k_2$,
$k_1 > k_2$. Then the abosolute value of the difference of the original
integer and the new one is $2^{k_1} - 2^{k_2}$. To minimise it, we
should *make $k_1$ as small as possible and $k_2$ as close to $k_1$*.

The bit at index $k_1$ must be different from the bit in $k_2$, this
means the smallest $k_1$ is the *rightmost bit that differs from the
LSB*, and *$k_2$ must be the very next bit*.

In summary, the correct approach is to *swap the two rightmost
consecutive bits that differ*.

#+BEGIN_SRC python
    def closest_int_same_bit_count(x):
        NUM_UNSIGNED_BITS = 64
        for i in range(NUM_UNSIGNED_BITS - 1):
            if (x >> i) & 1 != (x >> (i + 1)) & 1:
                # swap bit i and i+1
                x ^= (1 << i) | (1 << (i + 1))
                return x
        raise ValueError('All bits are 0 or 1'):
#+END_SRC

#+BEGIN_QUOTE
  The time complexity is $O(n)$, where $n$ is the width of the number.
#+END_QUOTE

Solve the same problem in $O(1)$ time and space.

*Recall that =x&~(x - 1)= indentifies the lowest set bit (rightmost
$1$).*

#+BEGIN_SRC python
    def closest_int_same_bit_count(x):
        # find the rightmost which differs from
        # the bit before (higher than) it
        y = x ^ (x >> 1)
        y = y & ~(y - 1)

        # swap them
        x ^= y | (y << 1)
        return x
#+END_SRC

** Compute $x \times y$ without Arithmetic Operations

*** Adding /non-negative/ numbers without $+$
#+BEGIN_SRC python
def add(a, b):
    # add with XOR
    running_sum, carry_in, k, temp_a, temp_b =\
    0,           0,           a,      b9
    while temp_a or temp_b:
        ak, bk = temp_a & k, temp_b & k
        carry_out = (ak & carry_in) | (bk & carry_in) | (ak & bk)

#+END_SRC
